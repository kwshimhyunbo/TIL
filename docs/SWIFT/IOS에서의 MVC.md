#MVC패턴
IOS에서의 MVC패턴은 여느 MVC패턴과 다르지 않다. 컨트롤러에서는 모델과 뷰를 이어주는 징검다리 역할을 하고 뷰는 컨트롤러와,
모델과 컨트롤러는 데이터를 주고 받으며 상호작용한다.

##모델과 뷰의 상관관계
이 둘은 절대 만날 수 없다. 모델과 뷰는 독립적으로 존재하기 때문에 서로 교류할 수도 없고 둘이 상호작용한다는 것은 전혀 말이 안된다.

##컨트롤러와 모델의 관계
###컨트롤러가 모델에게
컨트롤러는 모델의 모든 것을 통제할 수 있다. 언제든 원하면 호출해서 원하는 데이터를 가져올 수 있고, 또한 저장도 할 수 있다.
###모델이 컨트롤러에게
직접적으로 전달하는 것은 없지만 데이터가 변경되었다는 메시지를 간접적으로 알릴 수 있다.
보충 필요 -> Notificationm KVO


##컨트롤러와 뷰의 관계
###컨트롤러가 뷰에게
이 관계도 역시 뷰의 모든 것을 통제할 수 있는데, 이것은 Outlet변수를 통한 연결을 통해 가능하다. 이 연결을 통해 UILabel과 같은 것들에 접근할 수 있고,
통제할 수 있다.

###뷰가 컨트롤러에게
뷰는 컨트롤러에게 접근할 수도 있고 없을 수도 있다. 뷰가 컨트롤러에게 대화를 시도할 수 있는 상황은 상당히 제한적인데 몇가지 중 하나는 target_action을 이용하는 방법이다. 뷰에서 어떠한 액션이 취해졌을때 리스너형태로 설정을 하게되면 컨트롤러에서 그 액션에 대한 상황을 Catch해 해당 상황에 대해 대처할 수 있다.

또 다른 하나는 delegate다. 위의 예보다 더 복잡한 상황을 가정해보자. 인스타그램의 스크롤뷰를 생각하면 간단한데, 사용자가 스크롤을 계속해서 내려서 데이터를 얻고자할때 컨트롤러에게 지속적으로 데이터가 더 있는지 체크하는 상황을 생각해 볼 수 있다. 데이터가 있는지 없는지 뷰는 알 수 없으므로 컨트롤러에게 요청, 데이터의 유무를 체크하여 추가적으로 데이터를 제공해야 할 것이고 만약 없다면 스크롤뷰의 끝을 보여줌으로써 상황을 마무리할 수 있다.
